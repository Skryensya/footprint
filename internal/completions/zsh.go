package completions

import (
	"fmt"
	"sort"
	"strings"
)

// GenerateZsh generates a zsh completion script
func GenerateZsh(commands []CommandInfo) string {
	var b strings.Builder

	b.WriteString(`#compdef fp
# fp zsh completion script
# Generated by fp setup

_fp() {
    local curcontext="$curcontext" state line
    typeset -A opt_args

    _arguments -C \
        '(-h --help)'{-h,--help}'[Show help]' \
        '(-v --version)'{-v,--version}'[Show version]' \
        '--no-color[Disable colored output]' \
        '--no-pager[Do not use pager]' \
        '--pager=[Use specified pager]:pager:' \
        '1: :_fp_commands' \
        '*::arg:->args'

    case $state in
        args)
            case $line[1] in
`)

	// Generate case for each top-level command
	for _, cmd := range commands {
		if len(cmd.Path) != 2 {
			continue
		}

		b.WriteString(fmt.Sprintf("                %s)\n", cmd.Name))
		b.WriteString(fmt.Sprintf("                    _fp_%s\n", cmd.Name))
		b.WriteString("                    ;;\n")
	}

	b.WriteString(`            esac
            ;;
    esac
}

_fp_commands() {
    local -a commands
    commands=(
`)

	// Add all top-level commands with descriptions
	for _, cmd := range commands {
		if len(cmd.Path) != 2 {
			continue
		}
		summary := strings.ReplaceAll(cmd.Summary, "'", "'\\''")
		b.WriteString(fmt.Sprintf("        '%s:%s'\n", cmd.Name, summary))
	}

	b.WriteString(`    )
    _describe -t commands 'fp commands' commands
}

`)

	// Generate function for each command with subcommands or flags
	for _, cmd := range commands {
		if len(cmd.Path) != 2 {
			continue
		}

		b.WriteString(fmt.Sprintf("_fp_%s() {\n", cmd.Name))

		if len(cmd.Subcommands) > 0 {
			b.WriteString("    local -a subcommands\n")
			b.WriteString("    subcommands=(\n")

			// Find subcommand summaries
			for _, subcmdName := range cmd.Subcommands {
				subcmdPath := append(cmd.Path, subcmdName)
				if subcmd := FindCommand(commands, subcmdPath); subcmd != nil {
					summary := strings.ReplaceAll(subcmd.Summary, "'", "'\\''")
					b.WriteString(fmt.Sprintf("        '%s:%s'\n", subcmdName, summary))
				}
			}

			b.WriteString("    )\n\n")
			b.WriteString("    _arguments -C \\\n")

			// Add flags for the group
			for _, f := range cmd.Flags {
				flagStr := formatZshFlag(f)
				if flagStr != "" {
					b.WriteString(fmt.Sprintf("        %s \\\n", flagStr))
				}
			}

			b.WriteString("        '1: :->subcmd' \\\n")
			b.WriteString("        '*::arg:->args'\n\n")
			b.WriteString("    case $state in\n")
			b.WriteString("        subcmd)\n")
			b.WriteString("            _describe -t subcommands 'subcommands' subcommands\n")
			b.WriteString("            ;;\n")
			b.WriteString("    esac\n")
		} else {
			// Leaf command with just flags
			b.WriteString("    _arguments \\\n")
			for i, f := range cmd.Flags {
				flagStr := formatZshFlag(f)
				if flagStr != "" {
					if i < len(cmd.Flags)-1 {
						b.WriteString(fmt.Sprintf("        %s \\\n", flagStr))
					} else {
						b.WriteString(fmt.Sprintf("        %s\n", flagStr))
					}
				}
			}
			if len(cmd.Flags) == 0 {
				b.WriteString("        '*:file:_files'\n")
			}
		}

		b.WriteString("}\n\n")
	}

	b.WriteString("_fp \"$@\"\n")

	return b.String()
}

func formatZshFlag(f FlagInfo) string {
	if len(f.Names) == 0 {
		return ""
	}

	desc := strings.ReplaceAll(f.Description, "'", "'\\''")
	desc = strings.ReplaceAll(desc, "[", "\\[")
	desc = strings.ReplaceAll(desc, "]", "\\]")

	// Sort names to get short flag first
	names := make([]string, len(f.Names))
	copy(names, f.Names)
	sort.Slice(names, func(i, j int) bool {
		return len(names[i]) < len(names[j])
	})

	if len(names) == 2 {
		// Both short and long form
		short := names[0]
		long := names[1]
		if f.HasValue {
			return fmt.Sprintf("'(%s %s)'%s'[%s]:value:'", short, long, fmt.Sprintf("{%s,%s}", short, long), desc)
		}
		return fmt.Sprintf("'(%s %s)'{%s,%s}'[%s]'", short, long, short, long, desc)
	}

	// Single flag
	if f.HasValue {
		return fmt.Sprintf("'%s=[%s]:value:'", names[0], desc)
	}
	return fmt.Sprintf("'%s[%s]'", names[0], desc)
}
